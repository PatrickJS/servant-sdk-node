{
  "name": "z-schema",
  "description": "JSON schema validator",
  "homepage": "https://github.com/zaggino/z-schema",
  "keywords": [
    "json",
    "schema",
    "validator"
  ],
  "license": "MIT",
  "author": {
    "name": "Martin Zagora",
    "email": "zaggino@gmail.com",
    "url": "https://github.com/zaggino"
  },
  "contributors": [
    {
      "name": "Martin Zagora",
      "email": "zaggino@gmail.com",
      "url": "https://github.com/zaggino"
    },
    {
      "name": "Oleksiy Krivoshey",
      "email": "oleksiyk@gmail.com",
      "url": "https://github.com/oleksiyk"
    },
    {
      "name": "Jurie-Jan Botha",
      "url": "https://github.com/juriejan"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/zaggino/z-schema.git"
  },
  "main": "src/ZSchema.js",
  "files": [
    "src/ZSchema.js",
    "src/ZSchema.min.js",
    "LICENSE",
    "README.md"
  ],
  "version": "2.4.8",
  "dependencies": {
    "bluebird": ">=1.2.0",
    "request": ">=2.34.0"
  },
  "devDependencies": {
    "grunt": "latest",
    "grunt-contrib-uglify": "latest",
    "grunt-contrib-jshint": "latest",
    "grunt-simple-mocha": "latest",
    "chai": "latest",
    "mocha": "latest",
    "uglify-js": "latest"
  },
  "bugs": {
    "url": "https://github.com/zaggino/z-schema/issues",
    "email": "zaggino@gmail.com"
  },
  "scripts": {
    "prepublish": "grunt",
    "test": "grunt test"
  },
  "readme": "# z-schema validator\n\n[![NPM version](https://badge.fury.io/js/z-schema.png)](http://badge.fury.io/js/z-schema)\n[![Dependency Status](https://david-dm.org/zaggino/z-schema.png?theme=shields.io)](https://david-dm.org/zaggino/z-schema)\n\nJSON Schema validator for Node.js (draft4 version)\n\nCoded according to:\n\n[json-schema documentation](http://json-schema.org/documentation.html),\n[json-schema-core](http://json-schema.org/latest/json-schema-core.html),\n[json-schema-validation](http://json-schema.org/latest/json-schema-validation.html),\n[json-schema-hypermedia](http://json-schema.org/latest/json-schema-hypermedia.html)\n\nPassing all tests here (even optional, except zeroTerminatedFloats and some URI tests, see more info in [#18](https://github.com/zaggino/z-schema/issues/18)):\n\n[json-schema/JSON-Schema-Test-Suite](https://github.com/json-schema/JSON-Schema-Test-Suite)\n\nWill try to maintain this as much as possible, all bug reports welcome.\n\n### Grunt automatization\n\nIf you need to automatize validation of your schemas, there's a Grunt plugin [grunt-z-schema](https://github.com/petrbela/grunt-z-schema) by [Petr Bela](https://github.com/petrbela)\n\n### How does it compare to others?\n\n[rawgithub.com/zaggino/z-schema/master/benchmark/results.html](https://rawgithub.com/zaggino/z-schema/master/benchmark/results.html)\n\n## Basic Usage\n\n```javascript\nvar ZSchema = require(\"z-schema\");\n```\n\n```javascript\nZSchema.validate(json, schema)\n    .then(function(report){\n        // successful validation\n        // there might be warnings: console.log(report.warnings)\n    })\n    .catch(function(err){\n        console.error(err.errors)\n    })\n```\n\nThere is also support for _sync_ mode like this:\n```javascript\nvar validator = new ZSchema({ sync: true });\nvar valid = validator.validate(json, schema);\nif (!valid) {\n    var error = validator.getLastError();\n}\n```\n\nUsing traditional callback:\n```javascript\nZSchema.validate(json, schema, function(err, report){\n    if(err){\n        console.error(err.errors);\n        return;\n    }\n    // successful validation\n    // there might be warnings: console.log(report.warnings)\n})\n```\n\nIf you need just to validate your schema, you can do it like this:\n\n```javascript\nvar validator = new ZSchema();\nvalidator.validateSchema(schema)\n    .then(function(report){\n    })\n    .catch(function(err){\n    })\n```\n\nOr with Node.js style callback:\n\n```javascript\nvar validator = new ZSchema();\nvalidator.validateSchema(schema, function (err, report) {\n    if (err) ...\n});\n```\n\n## Remote references in schemas\n\nYour schemas can include remote references that should be real URIs ([more on that here](http://json-schema.org/latest/json-schema-core.html#anchor22))\nso validator can make a request and download the schema needed. Validator automatically\ncaches these remote requests so they are not repeated with every validation.\n\nIn case you don't have a real server or you'd like to load files from different location,\nyou can preload remote locations into the validator like this:\n\n```javascript\nvar fileContent = fs.readFileSync(__dirname + '/../json_schema_test_suite/remotes/integer.json', 'utf8');\nZSchema.setRemoteReference('http://localhost:1234/integer.json', fileContent);\n```\n\n```http://localhost:1234/integer.json``` doesn't have to be online now, all schemas\nreferencing it will validate against ```string``` that was passed to the function.\n\n## Advanced Usage\n\nYou can pre-compile schemas (for example on your server startup) so your application is not\nbothered by schema compilation and validation when validating ingoing / outgoing objects.\n\nPromises:\n\n```javascript\nvar validator = new ZSchema();\nvalidator.compileSchema(schema)\n    .then(function(compiledSchema){\n    })\n```\n\nOr callback:\n\n```javascript\nvar validator = new ZSchema();\nvalidator.compileSchema(schema, function (err, compiledSchema) {\n    assert.isUndefined(err);\n    ...\n});\n```\n\nThen you can re-use compiled schemas easily just the same way as non-compiled.\n\n```javascript\nvar validator = new ZSchema();\nvalidator.validate(json, compiledSchema)\n    .then(function(report){\n        // ...\n    })\n    .catch(function(err){\n        console.error(err.errors)\n    })\n```\n\n## Custom format validators\n\nYou can add validation for your own custom string formats like this:\n(these are added to all validator instances, because it would never make sense to have multiple\nfunctions to validate format with the same name)\n\n```javascript\nvar validator = new ZSchema();\n\nZSchema.registerFormat('xstring', function (str) {\n    return str === 'xxx'; // return true/false as a result of validation\n});\n\nvalidator.validate('xxx', {\n    'type': 'string',\n    'format': 'xstring'\n})\n.then(function(){})\n.catch(function(err){})\n```\n\nCustom validators can also be async:\n\nUsing promises:\n\n```javascript\nZSchema.registerFormat('xstring', function (str) {\n    return Q.delay(1000).thenResolve(return str === 'xxx'); // return a promise for validation result\n});\n```\n\nUsing classic callback:\n\n```javascript\nZSchema.registerFormat('xstring', function (str, callback) {\n    setTimeout(function(){\n        callback(null, str === 'xxx');\n        // or return custom error: callback(new Error('Bad, bad value!'))\n    }, 2000)\n});\n```\n\nAny exception thrown (or returned via classic callback) in custom validation function is written into validation error:\n```javascript\nZSchema.registerFormat('xstring', function (str) {\n    throw new Error('Bad, bad value!');\n});\n```\nAnd then expect errors to contain something like this:\n\n```\n[{ code: 'FORMAT',\n    message: 'xstring format validation failed: Error: Bad, bad value!',\n    path: '#/test',\n    params: { format: 'xstring', error: [Error: Bad, bad value!] } } ]\n```\n\n\n## Strict validation\n\nWhen creating new instance of validator, you can specify some options that will alter the validator behaviour like this:\n\n```javascript\nvar validator = new ZSchema({\n    option: true\n});\n```\n\n* noExtraKeywords: ```true/false```\n\nwhen true, do not allow unknown keywords in schema\n\n* noZeroLengthStrings: ```true/false```\n\nwhen true, always adds minLength: 1 to schemas where type is string\n\n* noTypeless: ```true/false```\n\nwhen true, every schema must specify a type\n\n* forceAdditional: ```true/false```\n\nwhen true, forces not to leave out some keys on schemas (additionalProperties, additionalItems)\n\n* forceProperties: ```true/false```\n\nwhen true, forces not to leave out properties or patternProperties on type-object schemas\n\n* forceItems: ```true/false```\n\nwhen true, forces not to leave out items on array-type schemas\n\n* forceMaxLength: ```true/false```\n\nwhen true, forces not to leave out maxLength on string-type schemas, when format or enum is not specified\n\n__Alternatively__, you can turn on all of the above options with:\n\n```javascript\nvar validator = new ZSchema({\n    strict: true\n});\n```\n\n## More options\n\n* noSchemaCache: ```true/false```\n\nwhen true, disables caching of compiled schemas - cache is used to resolve references to other schemas by their ID\n\n* strictUris: ```true/false```\n\nwhen true, uri's need to be in full rfc3986 format, by default checks for uri-fragment, more info in [#18](https://github.com/zaggino/z-schema/issues/18)\n\n# Pull requests\n\nAvoid JSHint errors - settings for the JSHint are specified in ```.jshintrc```.\nYou can check for errors using ```grunt``` command which runs both jshint and mocha tests.\nPlease check for errors before opening any pull requests.\n\n# Credits\n\n* Written by Martin Zagora, <zaggino@gmail.com>\n* Thanks to Oleksiy Krivoshey, <oleksiyk@gmail.com> for refactoring and new API (version 2.x) and bugfixing\n",
  "readmeFilename": "README.md",
  "_id": "z-schema@2.4.8",
  "_shasum": "cb9026b4576fbe90d5f02888e9055b0a2095d97f",
  "_from": "z-schema@2.4.8",
  "_resolved": "https://registry.npmjs.org/z-schema/-/z-schema-2.4.8.tgz"
}
